
## 설치
jdk깔고
JAVA_HOME 설정해주고
PATH추가
근데 오라클에서 자동으로 설정해주는 경로가 있고 PATH는 위에있으면 우선순위먹는다.
이클립스 preference - java - jdk bin까지 설정


## 자바 버전
Java SE : Standard Edition : 자바의 표준 플랫폼이자 핵심기능을 제공
Java EE : Enterprise Edition : Java SE를 포함하며 다계층, 엔터프라이즈 애플리케이션 개발 환경을 제공
Java ME : Micro Edition : 모바일장치, 셋톱박스, 프린터 등 사물인터넷, 임베디드용 API 및 환경을 제공
Java FX : 경량 사용자 인터페이스 API를 사용해 리치 인터넷 애플리케이션을 만들때 사용
Java Card, Java TV, Java Embedded 등 제한된 하드웨어 환경에서 동작하는 것도 있다.

## 목차
자바언어의 특징 및 개발환경 구축
자바 프로그램 작성(헬로월드)
변수
기본형 및 형변환
연산자와 연산식(단항, 산술, 비교, 논리, 대입)
조건문과 반복문
메모리 사용 영역
배열, 다차원 배열

메소드
객체
클래스, 유효범위, 접근제어자
생성자, 오버라이딩, 오버로딩, 중간복습
상속, 추상객체, 인터페이스
다형성
예외
컬렉션 프레임워크, 총복습


## 모르면 고생하지만 제대로 알려주지 않는 것
- 하나의 .java파일에 여러 클래스가 있어도 된다. 단, public 클래스는 하나만 있어야한다.
- 모든 변수는 클래스 안에 들어가야한다. (static은 아예 인스턴스가 없어도 생성되는 개념이니까 아무데서나 선언될수있다.)

### 1. getter setter쓰는 이유
객체의 무결성을 보장하기 위해.
객체지향. '은닉성'를 이해하지못해서 발생하는 의문이지만 좋은 의문이다.

예를들어 Man이라는 클래스의 weight라는 필드가 있고
weight에 -100이라는 값을 주려고 하면 무결성이 깨진다.

이를 방지하기 위해,
필드를 private로 만들어 외부의 접근을 제한한 후,
Setter를 사용해 전달받은 값을 내부에서 가공해 필드에 넣어주는 방식을 사용하고
마찬가지로 필드 값을 가져올 때도,
Getter를 사용해 본 필드의 값을 숨긴 채
내부에서 가공된 값을 꺼낼 수 있습니다.

또한 어떤 회사에서 유료 모듈을 팔면서 사용법을 알려주고 고객사가
사용법 대로 안하고 다른변수에 접근한다거나 올바르지 못한 값을 넣거나 하는 경우를 방지한다.

### 2. super의 의미
자바는 자식 생성자를 호출하기전에 부모 생성자를 자동으로 호출하도록 약속되어있다.
자바는 사용자정의 생성자가 없으면 기본생성자를 만들고, 사용자정의 생성자가 하나라도 있으면 기본생성자를 만들지 않는다.
부모에서 기본생성자가 아닌 명시적으로 정의한 생성자가 있다면 그것을 호출해야한다는 말.
상위 클래스와 하위클래스의 생성자가 하는역할이 같다면 코드를 복사해서 중복이 가져오는 여러 문제를 가져가는것이 아니라, 상위클래스의 생성자를 호출할수 있다면 좋겠지.
이때 사용하는 키워드가 super. 생성자의 코드가 길어질수록 그 효용은 분명하게 드러날 것이다.
하위클래스가 부모클래스를 먼저 초기화하고 자기자신을 초기화해야 한다면, 반드시 상위클래스의 생성자를 호출한 다음에 자신의 초기화에 필요한 코드가 나타나야 한다.

3. 캡슐화(encapsulation)
꼭 필요한 기능만 외부에 오픈 : 대부분의 멤버변수와 메서드를 감추고 외부에는 통합된 인터페이스만 제공하여 일관된 기능을 구현하게 함.
알 필요가 없거나 순서라든가 뭔가 잘못써서 오작동이 일어날수 있는건 노출하지 않는다.
캡슐화의 한 방법을 보자. 예를들어 private makeHeader, private generateBody, private makeFooter 는 숨기고
public String getReport(){
  makeHeader();
  generateBody();
  makeFooter();
  return buffer.toString();
}

4. 생성자 Constructor객체
문법 : 클래스명 (아규먼트 리스트){}.  반환값이 없고 클래스의 이름과 동일하다.
객체를 생성할 때 new 키워드와 함께 사용.
클래스에는 반드시 최소하나이상의 생성자가 존재.
클래스에 생성자가 명시적으로 없더라도 컴파일러가 디폴트 생성자를 넣어주기 때문에 new키워드와 함께 생성자를 호출가능.
디폴트 생성자는 매개변수와 구현부가 없다.



6. 자료형
기본자료형 : int, long, float, double 등
참조자료형 : String, Date, 클래스로 만든 객체 등
  참조자료형의 크기는 정해져있지 않다. 참조자료형은 new로 생성하여 사용하여야 하는데 String은 예외다.

7. 배열
동일한 자료형의 순차적인 자료구조.  인덱스를 활용하여 빠른 참조가능.



8. 객체
Object-Oriented Programming(OOP)
프로그램을 구성하는 로직을 '상태' 와 '행위'로 구분해서 서로 연관된 상태와 행위를 그룹화한 것. 프로그램으로 구현할 대상.
즉, 서로 연결된것 끼리 객체라는 껍데기를 중심으로 응집시킨것.
예를들어 댓글기능을 만들었는데 다른 웹사이트에서도 사용할 수 있겠다는 생각이 든다. 이것이 재활용성.
그런데 다른곳에 실제로 사용하려고 하니까 여러가지 문제가 발생한다.
이러한 문제를 완화하기 위해 여러가지 방법, 기능들이 탄생했다.
'추상화' : 추상화는 해결해야 할 문제 또는 반영해야 할 현실을 소프트웨어 방식으로 단순화하는 행위를 말한다.
소프트웨어를 설계한다는 것은 복잡한 현실을 추상화하는 과정이라고 볼 수 있다.
예) 실제 위성사진 -> 네이버 지도 -> 실제 위치로 박힌 지하철 노선도 -> 우리가 보는 지하철 노선도
'부품화' : 객체를 다른곳에서 재사용한다는 것은 객체가 다른 곳에서 부품으로써 사용되는 것이다.
좋은 객체를 만든다는 것은 로직을 재활용할 수 있게 부품화하는 것.
예) 초창기의 컴퓨터.  현재의 컴퓨터 : 모니터, 본체, 키보드 등이 분리. 그안에서도 또 분리. 어디가 고장났는지 쉽게 알수있고 그것만 교체하면된다.
시대에 따라, 환경에 따라 부품화 및 추상화의 관점은 계속 바뀐다. 무조건 부품화를 하는것이 좋은것이 아니다. 정답이 없다.
메소드도 부품화의 예. 메소드가 도입되면서 과거와 비교해서 훨씬 편하게 프로그래밍 할 수 있게 되었으나 소프트웨어의 규모가 커지면서 또다시 메소드가 없었을때와 같은 경험을 하게됨. 그리하여 도출된 기능이 객체지향.
'은닉화, 캡슐화' : 어떻게 동작하는지 원리를 몰라도 사용법만 알면 사용할 수 있다. 즉, 객체가 어떻게 생겼는지 몰라도 객체를 사용할 수 있게 하자는 것.
(본체와 모니터를 연결하는 법만 알면 모니터 사용가능)
'인터페이스' : 규격을 표준화하면 다른것으로 교체가능.

# 프로그래밍의 5원칙
<초보용>
- Divide and Conquer(작은 문제로 나눠서 분할정복하라)
- 중복의 제거
- 가독성을 높여라(주석, 네이밍, 들여쓰기)

SOLID
1. SRP (단일책임의 원칙 : Single Responsibility Principle)
2. OCP (개방폐쇄의 원칙 : Open Close Principle) : 확장에는 열려있고 변경에는 닫혀있어야 한다.
3. LSP (리스코브 치환의 원칙 : The Liskov Subsitution Principle) : 서브타입은 언제나 기반타입으로 교체될수 있어야 한다. 다형성을 통한 확장성
4. ISP (인터페이스 분리의 원칙 : Interface Segregation Principle)
5. DIP (의존성역전의 원칙 : Dependency Inversion Principle)

## 상속
언제 사용할까?
  1. IS-A 관계 (inheritance)   일반적개념과 구체적관계
  2. HAS-A 관계 (composition)


## 다형성 Polymorphism
- 하나의 코드가 여러 자료형으로 구현되어 다른 실행결과를 실행되게끔 하는 기술
- 정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나
- 다형성을 잘 활용하면 유연하고, 확장성있고 유지보수가 편리한 프로그램을 만들수 있다.
예)
```java
Animal 독수리 = new 독수리();
Animal 호랑이 = new 호랑이();
Animal 코끼리 = new 코끼리();

public void moveAnimal(Animal animal){
  animal.move();
}
가 있을때 아래와 같이 호출하면
test.moveAnimal(독수리)
test.moveAnimal(호랑이)
test.moveAnimal(코끼리)
다 제각각의 오버라이드된 move가 호출된다.
```
예2)
```java
고객 customerT = new GoldCustomer(10030, "Edward");
고객 CustomerP = new VIPCustomer(10050, "Kim")

```


## 배열 Array
같은 데이터타입의 연관된 여러개의 데이터를 하나의 변수에 담아서 쉽게 관리할수 있도록 해주는 자료구조중 하나
문법 : 선언및 초기화
```Java
//크기 할당 & 초기화 없이 배열 참조변수만 선언
int[] arr;
int arr[];

// 선언과 동시에 배열 크기 할당
int[] arr = new int[5];
String[] arr = new String[5];

// 기존 배열의 참조 변수에 초기화 할당하기
int[] arr; arr = new int[5]; //5의 크기를 가지고 초기값 0으로 채워진 배열 생성

// 선언과 동시에 배열의 크기 지정 및 값 초기화
int[] arr = {1,2,3,4,5};
int[] arr = new int[] {1,3,5,2,4};
int[] odds = {1,3,5,7,9};
String[] weeks = {"월","화","수","목","금","토","일"};

// 2차원 배열 선언
int[][] arr = new int[4][3]; //3의 크기의 배열을 4개 가질 수 있는 2차원 배열 할당
int[][] arr9 = { {2, 5, 3}, {4, 4, 1}, {1, 7, 3}, {3, 4, 5}};

```

데이터는 중괄호로 감싸고 각값은 쉼표로 구분. 데이터의 모임이라는 표시를 하는 []에 저장.
  데이터타입[] 배열명 = {해당데이터타입의 데이터1, 해당데이터타입의 데이터2, 해당데이터타입의 데이터3...}
설명 :
  변수의 진정한 의미 :  "반장 이리 와봐" 라고 하면 선생님은 그반의 반장이 누군지 몰라도됨. 반장이 바뀌더라도 반장이 호출됨.  하드코딩 방지(유연성 증가)
  배열의 진정한 의미 : 순서가 원소들이 어느 집합에 소속됨.  "5번 p.5페이지 읽어"  5번이 누군지 몰라도됨.
                      1번 상담끝, 다음 2번, 다음 3... 학생의 총원과 상담한인원이 같으면 상담 끝.
핵심 :
  - **인덱스(index)** : 색인 : 내용이 어디에 적혀있는지 알려주는 역할. 주소를 나타냄. 0부터 시작.
  - 정의할때 반드시 배열에 몇개의 값을 담을수 있는지 꼭 지정해야 한다. 즉 **배열의 길이는 최초 선언한 값으로 고정**됨. 배열의 최대단점
  - 배열이 갖고있지 않은 인덱스에 접근하면 OutOfBoundsException발생. 파이썬이나 자바스크립트 같은 고급언어에서는 크기가 자연적으로 변경되는데 자바는 왜 이렇게 융통성이 없게 만들어놨을까?
  현실에서 50가구가 살 아파트를 지었는데, 이미 짓고나면 51가구가 들어올수있나? 없다.
  그럼 50가구를 살 것이지만 넉넉잡아서 100가구가 살도록 만들면 안되나?  부동산 가격이 매우 비싸기 때문에 현실적으로 불가능.
  바로 컴퓨터 세상에서도 가장 비싼자원인 메모리에 공간을 할당받기 때문에 딱맞게 쓸만큼만 할당해서 효율적으로 사용해야 한다.**메모리에 연속적으로 할당됨.**
  그런데 자원의 효율적인 활용을 위해서 인간이 너무 불편하다. 그 불편을 극복한것이 **컬렉션(Collection)**
  - length메서드는 배열에 담겨있는 원소의 갯수가 아니라 배열에 담을수 있는 원소의 갯수다. 고급언어에 속하는 좀더 쉬운언어에서는 보통 담긴 갯수가 리턴된다.
  - 향상된 for문을 for-each문이라고 한다. while문에서 반복해서 사용하는 패턴을 따로 문법적으로 승화한것. 배열과 반복문은 매우 밀접한 관계
    이 문법이 없다면 배열의 담긴 값을 하나씩 꺼내서 처리하는것을 위해서 배열의 크기를 알아야하고, 반복을 위한 기본값을 세팅해야하고, 그것을 1씩 증가시켜야 하는 노가다 작업의 불편함이 있다.
```Java
  String[] memebers = {"최진혁", "최유빈", "한이람"};
  for String e : members){
    System.out.println(e +"이 상담을 받았습니다.");  //하나하나의 원소에 대해서 무슨처리를 할것인지
  }

```

## 메소드 Method
메소드와 함수는 같은 의미.
설명 : 자주 사용될만한 특정작업을 정의해두고 호출할때는 한문장으로 써서 코드의 양을 극단적으로 줄일수 있으며 재활용성이 높아진다. 유지보수가 유리해진다.

문법 :
  접근제한자 리턴타입 메소드명(인자타입 인자명, 인자타입 인자명...){
    함수본문;
    리턴타입 void가 아닐경우 리턴문;
  }
핵심 :
- 메소드가 없다면 얼마나 불편한지 체감해야한다.
- 매개변수-파라미터(parameter)와 전달인자-아규먼트(argument)는 서로다른것.
  매개변수는 정의할때 나열한 변수
  전달인자는 함수를 호출할때 전달되는 실제값
- 마찬가지로 왜 귀찮게 리턴타입이나 인자 타입을 명시적으로 지정해두게 했을까?
  모든일에는 장단점이 있고 언어의 철학에 따라 선택된다.
  String으로 고정되면 사용하는쪽에서는 String이 아닐거라는 생각을 할 필요가 없어진다. 그래서 문자열인지 숫자인지 체크하는 조건문같은것을 안넣어도된다. 컴파일시 에러를 발견할수 있다.
- return을 만나면 리턴뒤에 오는 값을, 메소드를 호출한곳으로 돌려주면서 메소드의 실행을 완전히 종료한다.
  그럼 왜 본문에서 처리안하고 return으로 결과값을 외부로 돌려주는 방법을 쓰는가?
  부품으로써 사용하기 위해서
  어떤 특정한 용도로만 사용할 수 있는 부품이 된다는 것은(예를들어 화면에 출력) 부품으로서의 가치가 떨어진다는 말과 같다.
- 배열은 메소드와도 매우 밀접한 관계
  인자나 리턴으로 여러개의 값을 다룰수 있게 한다.


## 객체지향
- 서론
  이제 자바 수업의 중간이다.
  사실 이때까지 배운것은 모두 절차적 프로그래밍이였다. 절차지향이라는 탄탄한 토대위에서 객체지향은 구축된다.
  자바는 객체지향을 강제하고있다. 그러나 문법적으로 강제한다고 해서 객체지향적 코딩을 할수있는것은 아니다.
  한국어 문법에는 어긋난것이 없지만 아무런 의미를 전달할 수 없거나 이상한 의미를 전달하는 것처럼.

### Object Oriented Programming (OOP)
객체를 지향한다는것이 도대체 무슨말인가? 객체를 먼저 이해해야한다.
객체 : 서로관련있는 **상태**와 **행위**로 모아둔 집합
    *상태 : 변수
    *행위 : 메소드
    그 객체들을 블록처럼 조합해서 하나의 완제품을 만드는것이 객체지향 프로그래밍.
	핵심은 객체들간의 '관계'다.
객체의 기능과 역할 :
  - 높은 응집도
  - 재활용성
  - ### 추상화 : 현실의 미치도록 복잡한 것에서 관심있는 요소에만 집중해서 단순화하여 추출한 것
  즉 해결해야할 현실의 문제를 소프트웨어 방식으로 단순화하는 행위.
  예) 위성사진 -> 지적도 -> 실제 노선도 -> 우리가보는 노선도
  - ###  부품화 : 객체를 다른객체에서 재사용할 수 있게 만드는 것
  예) 초창기의 일체형 컴퓨터 : 하나만 고장나면 통째로 바꿔야한다. 부품화하면 키보드, 스피커, 모니터, 램 고장난 그것만 바꾸면됨. 무엇이 고장났는지 쉽게 알수있음.
  요즘 애플에서 새로 나오는 컴퓨터는 다시 단일화 됐는데요? 부품이 경량화되면서 부품화에 대한 매력이 반감되는 등 시대에 따라 관점이 계속 바뀌기 때문.
  소프트웨어 세상에서는 부품의 설계도를 바꾸면 그 부품을 사용하고있는 모든 곳에서 동시다발적으로 개선이 이루어짐.
  메소드는 부품화의 예
    - 은닉화(Information Hiding), 캡슐화(Encapsulation) : 어떻게 만들어졌는지, 동작원리가 뭔지를 몰라도 사용할수있음. 내부의 속성과 동작방법은 캡슐안에 숨기고 사용자에게는 사용법만 노출

    객체, 인스턴스, 상속, 추상클래스, 인터페이스
      - ## 객체 : 소프트웨어로 구현할 대상. 개념.
      - ## 인스턴스 : 클래스(설계도)로 구현된 구체적인 실체
      - ## 추상클래스 : extends 하나의 부모'만' 가질수있다.
            클래스가 미완성이라는것은 추상메소드가 하나 이상 포함된 클래스라는 말.
            추상클래스로 인스턴스 생성은 불가능. 상속을 통해서 자식클래스에 의해서만 인스턴스를 생성할 수 있다.   부모가 만들어놓은것을 이어받아 자식이 완성시켜야한다.
            즉 상속을 강제하기위한 클래스다.
            사용목적 : 공통구현을 상위클래스에 뽑아내기위함
              왜 공통구현을 하지? : 코드의 중복을 제거.
            왜 추상메소드를 뒀을까? : 맥락에 따라 달라질 수 있는 기능이 있을때. 즉 코드의 중복을 막고 유지보수를 편하게 하려고.
      - ## 인터페이스 : 부품들의 결합방식에 대한 약속. 다형성을 구현하는 매우 중요한 역할을 한다.

      예) DVI, RGB, HDMI, DP
      다른 표준대로 만들어진 제품을 꽂으려고 하면 꽂아지는데 동작이 안되는것이 아니라 아예 꽂아지지도 않게 만들어서 고장의 위험을 미리 방지.
      ** '역할'은 인터페이스에 '구현'은 구현체에 **
        문법 : implements 구현할 인터페이스. 여러개의 인터페이스를 구현할수있다.
      예) 220v(동그란구멍 2개), 110v(길죽한 구멍2개)
          HDMI, DP, DVI, RGB
          모양, 핀의수, 데이터의형식 이런게 다르기 때문에 꽂았을때 에러가 나오는것이 아니라 아예 꼽지도 못하도록 만드는 역할
            추상클래스보다 더 추상적(모든메소드가 추상메소드)이여서 본문이 없고 어떻게 구현해야한다고 약속만 한것. 그냥 함수이름만 쓰면 앞에 public abstract이 생략된것.
            멤버변수는 상수(final)만 가질수있다. 이건 반드시 있어야 되거든? 반드시 구현해줘.
            사용목적 : 기능의 강제, 협업
      예2) k3, 아반떼, 테슬라 모델3, 페라리 뭐가됐든 자동차역할을 한다면 운전하다 기능으로 다 운전가능
      예3) 로미오 역할을 구현하는 애가 장동건이든 원빈이든 현빈이든 로미오로 쓰인다.
      쥴리엣.키스하다(로미오)     
      Romeo = new 장동건();  이든 Romeo = new 원빈(); 이든
      Juleit.kiss(Romeo)
      실습)
      Animal이라는 추상클래스
      flyer (비행자) 라는 인터페이스
      호랑이, 토끼, 독수리 객체3개를 만들어서 모두 Animal을 상속받고
      독수리만 flyer를 implements 하도록

      추상클래스 vs 인터페이스
      외우는것이 아니지만 진짜 이해가 안돼서 외우도록 가이드를 주자면
      같은 코드를 반복해야돼서 부모의 것을 물려받아서 중복을 막는다면 추상클래스
      반드시 구현해야하는 기능의 약속이면 인터페이스


      - ## this : 인스턴스화 됐을때의 그 인스턴스 자신을 가르키는 키워드.
      인스턴스 자신의 메모리 주소를 가르키고 반환함.
      생성자에서 또다른 생성자를 호출할때 사용.
              똑같은 변수가 있다면 구분하기 위해서 this를 써줘야한다. 전달받은것이 없다면 의심의 여지가 없기 때문에 this에서 찾는다. 그러나 this를 붙이는것을 습관화하자.
      -  ## super : 인스턴스화 된 자신의 부모
      - 모든 객체의 부모에는 최종조상인 Object를 자동으로 상속받고있다.
      - 부모클래스의 private 은 자식이 물려받을 수 없다.

    실습 : 추상클래스 자동차(이름, 무게, 최고탑승객수, 현재승객수, 최고속도, 현재속도),
    슈퍼카(터보엔진 등등)
    대중교통(요금을 받는기능:charge, 승객 태우기:take, 승객 내리기:getOff, 최고인원수에 도달했는지 체크하는기능:checkMaxCount)



## 클래스 Class
객체를 만들기 위한 설계도
클래스를 만든다는것은 사용자정의 데이터타입을 직접 만드는것

## 인스턴스 instance
설계도를 따라서 만든 구체적인 제품

## 객체


## 불편함을 넘어서 절망감을 받아야 한다.
1개를 쉽게함. 비슷한걸 5개를 만들라고? 불편함.
비슷한걸 만개를 만들라고? 절망감.
어떻게 하면 편하게 할수있을까? 역사적으로 수많은 선대의 개발자들이 그것을 해결하려는 노력을 했고 해소되어왔다.


### static 과 final
static : 메모리에 한번 할당되어 프로그램이 종료될때까지 해제되지 않도록해준다.
    변수나 메소드앞에 붙어 전역(정적)화 시킨다. 인스턴스를 만들 필요가 없다.
  Cannot make a static reference to the non-static method 에러 : static멤버가 먼저 컴파일 되기 때문에 static멤버의 컴파일 시점에서는 static이 아닌 메서드나 필드는 정의되지 않았기 때문에 사용할 수 없다.
  사용이유 : 공유, 메모리의 이점
  실습 :
  ```java
  public class Counter  {
      static int count = 0;
      Counter() {
          this.count++;
          System.out.println(this.count);
      }

      public static void main(String[] args) {
          Counter c1 = new Counter();
          Counter c2 = new Counter();
      }
  }
  ```
  - 보통 스태틱 메소드는 유틸리티성 메소드(공통함수)에 많이 사용된다. 예를들어 오늘날짜 구하기, 숫자에 컴마 추가하기
  - 싱글톤 디자인패턴과 관련이 깊다.  단 하나의 객체만을 생성하도록 강제하는 패턴. static과 생성자에 대한 이해가 되었다면 바로 이해된다.

  ```java
  class Singleton {
      private static Singleton one;
      private Singleton() {
      }

      public static Singleton getInstance() {
          if(one==null) {
              one = new Singleton();
          }
          return one;
      }
  }

  public class SingletonTest {
      public static void main(String[] args) {
          Singleton singleton1 = Singleton.getInstance();
          Singleton singleton2 = Singleton.getInstance();
          System.out.println(singleton1 == singleton2);
      }
  }
  ```
    생성자를 private으로 막고 외부 에서 생성할수 없도록 한다. 그리고 자기가 생성자를 호출.
final : 상수
